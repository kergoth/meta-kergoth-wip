#!/usr/bin/env python
#
# Determine dependencies of python scripts or available python modules in a search path.
#
# Given the -d argument and a filename/filenames, returns the modules imported by those files.
# Given the -d argument and a directory/directories, recurses to find all
# python packages and modules, returns the modules imported by these. In this
# mode, each package gets imported, so beware of packages whose import causes
# side effects.
# Given the -p argument and a path or paths, scans that path for available python modules/packages.

import argparse
import ast
import imp
import logging
import os.path
import sys


logger = logging.getLogger('pythondeps')

suffixes = []
for triple in imp.get_suffixes():
    suffixes.append(triple[0])


class PythonDepError(Exception):
    pass


class DependError(PythonDepError):
    def __init__(self, path, error):
        self.path = path
        self.error = error
        PythonDepError.__init__(self, error)

    def __str__(self):
        return "Failure determining dependencies of {}: {}".format(self.path, self.error)


class ImportVisitor(ast.NodeVisitor):
    def __init__(self):
        self.imports = set()

    def visit_Import(self, node):
        for alias in node.names:
            self.imports.add(alias.name)

    def visit_ImportFrom(self, node):
        self.imports.add(node.module)


def get_provides(path):
    if not path.endswith('/'):
        path = path + '/'

    provides = set()
    for root, dirnames, filenames in os.walk(path):
        full_root = root
        root = root[len(path):]
        if root and '__init__.py' not in filenames:
            dirnames[:] = []
            continue

        if root:
            provides.add((root.replace('/', '.'), full_root))

        for filename in filenames:
            for suffix in suffixes:
                if filename.endswith(suffix):
                    base = filename[:-len(suffix)]
                    if base != '__init__':
                        fullpath = os.path.join(root, base)
                        provides.add((fullpath.replace('/', '.'), os.path.join(full_root, filename)))

    return provides


def get_code_depends(code_string, path=None):
    try:
        code = ast.parse(code_string, path)
    except TypeError as exc:
        raise DependError(path, exc)
    except SyntaxError as exc:
        raise DependError(path, exc)

    visitor = ImportVisitor()
    visitor.visit(code)
    for builtin_module in sys.builtin_module_names:
        if builtin_module in visitor.imports:
            visitor.imports.remove(builtin_module)

    for module in visitor.imports:
        yield module, path


def get_file_depends(path):
    try:
        code_string = open(path, 'r').read()
    except (OSError, IOError) as exc:
        raise DependError(path, exc)

    return get_code_depends(code_string, path)


def get_depends_recursive(directory):
    import pkgutil
    directory = os.path.realpath(directory)

    sys.path[0:0] = [directory]
    for imp, name, ispkg in pkgutil.walk_packages([directory]):
        loader = imp.find_module(name)
        if ispkg or '.' in name:
            package = name.split('.')[0]
            modules = list(m for m, i in imp.iter_modules())
        else:
            modules = []

        filename = loader.get_filename()
        if not filename.startswith(directory + '/'):
            raise DependError(directory, "Package walking encountered path `{}`, outside the tree".format(filename))

        if not filename.endswith('.py'):
            continue

        depends = list(get_code_depends(loader.get_source(), filename))
        for depend, by in depends:
            if depend.startswith('.'):
                depend = depend[1:]
                yield '{}.{}'.format(package, depend), by
            elif depend in modules:
                yield '{}.{}'.format(package, depend), by
            else:
                yield depend, by


def get_depends(path):
    if os.path.isdir(path):
        return get_depends_recursive(path)
    else:
        return get_file_depends(path)


def main():
    logging.basicConfig()

    parser = argparse.ArgumentParser(description='Determine dependencies and provided packages for python scripts/modules')
    parser.add_argument('path', nargs='+', help='full path to content to be processed')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-p', '--provides', action='store_true',
                       help='given a path, display the provided python modules')
    group.add_argument('-d', '--depends', action='store_true',
                       help='given a filename, display the imported python modules')

    args = parser.parse_args()
    if args.provides:
        modules = set()
        for path in args.path:
            for provide, filename in get_provides(path):
                modules.add(provide)

        for module in sorted(modules):
            print(module)
    elif args.depends:
        modules = set()
        for path in args.path:
            try:
                modules |= set(get_depends(path))
            except PythonDepError as exc:
                logger.error(str(exc))
                sys.exit(1)

        for module, imp_by in sorted(modules):
            print("{} {}".format(module, imp_by))
    else:
        parser.print_help()
        sys.exit(2)


if __name__ == '__main__':
    main()
